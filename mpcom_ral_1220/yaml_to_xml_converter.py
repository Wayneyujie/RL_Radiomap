#!/usr/bin/env python3
"""
YAML to XML Converter for Radio Shadowing Simulation

This script converts YAML configuration files (used by ir_sim)
to Mitsuba XML scene format (used by radio_shadowing.py).

Author: Claude Code Assistant
Date: 2024
"""

import yaml
import numpy as np
import xml.etree.ElementTree as ET
from xml.dom import minidom
import argparse
import os
import sys

class YAMLToXMLConverter:
    def __init__(self):
        """Initialize the converter with default parameters"""
        self.materials = {
            'itu_marble': {'type': 'diffuse', 'reflectance': '1.000000 0.000000 0.300000'},
            'itu_glass': {'type': 'diffuse', 'reflectance': '1.000000 1.000000 1.000000'},
            'itu_metal': {'type': 'diffuse', 'reflectance': '1.000000 0.000000 0.300000'},
            'itu_concrete': {'type': 'diffuse', 'reflectance': '1.000000 0.000000 0.300000'}
        }

        # Default material for obstacles
        self.default_obstacle_material = 'itu_concrete'

        # Default obstacle height in meters
        self.default_obstacle_height = 2.0

        # Ground material
        self.ground_material = 'itu_concrete'

    def load_yaml(self, yaml_file):
        """Load YAML configuration file"""
        try:
            with open(yaml_file, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)
            print(f"‚úì Successfully loaded YAML: {yaml_file}")
            return config
        except Exception as e:
            print(f"‚ùå Error loading YAML file: {e}")
            return None

    def create_xml_root(self):
        """Create the root XML element for Mitsuba scene"""
        root = ET.Element('scene')
        root.set('version', '2.1.0')

        # Add comment about the converter
        comment = ET.Comment(" Generated by YAML to XML Converter for Radio Shadowing ")
        root.append(comment)

        return root

    def add_materials(self, root):
        """Add material definitions to XML"""
        materials_comment = ET.Comment(" Materials ")
        root.append(materials_comment)

        for mat_id, mat_props in self.materials.items():
            bsdf = ET.SubElement(root, 'bsdf')
            bsdf.set('type', mat_props['type'])
            bsdf.set('id', mat_id)
            bsdf.set('name', mat_id)

            rgb = ET.SubElement(bsdf, 'rgb')
            rgb.set('value', mat_props['reflectance'])
            rgb.set('name', 'reflectance')

    def add_ground_plane(self, root, world_config):
        """Add ground plane to the scene"""
        ground_comment = ET.Comment(" Ground Plane ")
        root.append(ground_comment)

        world_width = world_config.get('width', 20)
        world_height = world_config.get('height', 20)

        ground = ET.SubElement(root, 'shape')
        ground.set('type', 'cube')
        ground.set('id', 'ground_plane')

        transform = ET.SubElement(ground, 'transform')
        transform.set('name', 'to_world')

        # Scale to world dimensions with small thickness
        scale = ET.SubElement(transform, 'scale')
        scale.set('x', str(world_width))
        scale.set('y', str(world_height))
        scale.set('z', str(0.1))

        # Position at origin
        translate = ET.SubElement(transform, 'translate')
        translate.set('x', str(world_width/2))
        translate.set('y', str(world_height/2))
        translate.set('z', str(-0.05))

        # Add material
        ref = ET.SubElement(ground, 'ref')
        ref.set('id', self.ground_material)

    def add_boundary_walls(self, root, world_config, wall_thickness=0.2, wall_height=3.0):
        """Add boundary walls around the world"""
        walls_comment = ET.Comment(" Boundary Walls ")
        root.append(walls_comment)

        world_width = world_config.get('width', 20)
        world_height = world_config.get('height', 20)

        wall_positions = [
            # North wall
            {'id': 'north_wall', 'x': world_width/2, 'y': -wall_thickness/2,
             'width': world_width, 'depth': wall_thickness},
            # South wall
            {'id': 'south_wall', 'x': world_width/2, 'y': world_height - wall_thickness/2,
             'width': world_width, 'depth': wall_thickness},
            # East wall
            {'id': 'east_wall', 'x': -wall_thickness/2, 'y': world_height/2,
             'width': wall_thickness, 'depth': world_height},
            # West wall
            {'id': 'west_wall', 'x': world_width - wall_thickness/2, 'y': world_height/2,
             'width': wall_thickness, 'depth': world_height}
        ]

        for wall in wall_positions:
            wall_elem = ET.SubElement(root, 'shape')
            wall_elem.set('type', 'cube')
            wall_elem.set('id', wall['id'])

            transform = ET.SubElement(wall_elem, 'transform')
            transform.set('name', 'to_world')

            scale = ET.SubElement(transform, 'scale')
            scale.set('x', str(wall['width']))
            scale.set('y', str(wall['depth']))
            scale.set('z', str(wall_height))

            translate = ET.SubElement(transform, 'translate')
            translate.set('x', str(wall['x']))
            translate.set('y', str(wall['y']))
            translate.set('z', str(wall_height/2))

            ref = ET.SubElement(wall_elem, 'ref')
            ref.set('id', self.default_obstacle_material)

    def polygon_to_bounds(self, vertices):
        """Convert polygon vertices to bounding box"""
        vertices = np.array(vertices)
        min_coords = np.min(vertices, axis=0)
        max_coords = np.max(vertices, axis=0)

        width = max_coords[0] - min_coords[0]
        depth = max_coords[1] - min_coords[1]
        center_x = (min_coords[0] + max_coords[0]) / 2
        center_y = (min_coords[1] + max_coords[1]) / 2

        return center_x, center_y, width, depth

    def add_obstacles(self, root, obstacles_config):
        """Add obstacles from YAML configuration to XML"""
        if not obstacles_config:
            return

        obstacles_comment = ET.Comment(" Obstacles from YAML ")
        root.append(obstacles_comment)

        for i, obstacle_group in enumerate(obstacles_config):
            if 'obstacle_polygon' in obstacle_group.get('type', ''):
                states = obstacle_group.get('distribute', {}).get('states', [])
                shapes = obstacle_group.get('distribute', {}).get('shapes', [])

                for j, (state, shape) in enumerate(zip(states, shapes)):
                    if len(state) >= 2 and len(shape) >= 3:  # Ensure valid data
                        # Extract obstacle position and vertices
                        x, y, theta = state[0], state[1], state[2] if len(state) > 2 else 0

                        # Convert polygon to bounding box
                        center_x, center_y, width, depth = self.polygon_to_bounds(shape)

                        # Add obstacle to XML
                        obstacle_elem = ET.SubElement(root, 'shape')
                        obstacle_elem.set('type', 'cube')
                        obstacle_elem.set('id', f'obstacle_{i}_{j}')

                        transform = ET.SubElement(obstacle_elem, 'transform')
                        transform.set('name', 'to_world')

                        scale = ET.SubElement(transform, 'scale')
                        scale.set('x', str(width))
                        scale.set('y', str(depth))
                        scale.set('z', str(self.default_obstacle_height))

                        translate = ET.SubElement(transform, 'translate')
                        translate.set('x', str(x))
                        translate.set('y', str(y))
                        translate.set('z', str(self.default_obstacle_height/2))

                        # Add rotation if specified
                        if abs(theta) > 0.01:
                            rotate = ET.SubElement(transform, 'rotate')
                            rotate.set('x', '0')
                            rotate.set('y', '0')
                            rotate.set('z', '1')
                            rotate.set('angle', str(np.degrees(theta)))

                        # Add material
                        ref = ET.SubElement(obstacle_elem, 'ref')
                        ref.set('id', self.default_obstacle_material)

                        print(f"  ‚úì Added obstacle_{i}_{j} at ({x:.2f}, {y:.2f}) size ({width:.2f}x{depth:.2f})")

    def add_robot_transmitter(self, root, robot_config):
        """Add robot transmitter position for radio simulation"""
        if not robot_config:
            return

        transmitter_comment = ET.Comment(" Robot Transmitter Position (for reference) ")
        root.append(transmitter_comment)

        state = robot_config.get('state', [0, 0, 0, 0])
        x, y, theta, v = state[0], state[1], state[2] if len(state) > 2 else 0, state[3] if len(state) > 3 else 0

        # Add a small cube to represent robot position (visual reference only)
        robot_marker = ET.SubElement(root, 'shape')
        robot_marker.set('type', 'cube')
        robot_marker.set('id', 'robot_position_marker')

        transform = ET.SubElement(robot_marker, 'transform')
        transform.set('name', 'to_world')

        scale = ET.SubElement(transform, 'scale')
        scale.set('x', '0.5')
        scale.set('y', '0.3')
        scale.set('z', '0.2')

        translate = ET.SubElement(transform, 'translate')
        translate.set('x', str(x))
        translate.set('y', str(y))
        translate.set('z', str(0.1))

        # Add rotation if specified
        if abs(theta) > 0.01:
            rotate = ET.SubElement(transform, 'rotate')
            rotate.set('x', '0')
            rotate.set('y', '0')
            rotate.set('z', '1')
            rotate.set('angle', str(np.degrees(theta)))

        # Add material (different color for visibility)
        ref = ET.SubElement(robot_marker, 'ref')
        ref.set('id', 'itu_metal')

        print(f"  ‚úì Added robot position marker at ({x:.2f}, {y:.2f})")

    def prettify_xml(self, elem):
        """Return a pretty-printed XML string for the Element"""
        rough_string = ET.tostring(elem, encoding='unicode')
        reparsed = minidom.parseString(rough_string)
        return reparsed.toprettyxml(indent="  ")

    def convert(self, yaml_file, xml_file):
        """Main conversion function"""
        print(f"üîÑ Converting {yaml_file} to {xml_file}...")

        # Load YAML configuration
        config = self.load_yaml(yaml_file)
        if not config:
            return False

        # Create XML structure
        root = self.create_xml_root()

        # Add materials
        self.add_materials(root)

        # Add emitters section (empty for now)
        emitters_comment = ET.Comment(" Emitters ")
        root.append(emitters_comment)

        # Add ground plane
        self.add_ground_plane(root, config.get('world', {}))

        # Add boundary walls
        self.add_boundary_walls(root, config.get('world', {}))

        # Add obstacles
        self.add_obstacles(root, config.get('obstacles', []))

        # Add robot transmitter position
        self.add_robot_transmitter(root, config.get('robots', {}))

        # Add shapes section comment
        shapes_comment = ET.Comment(" Generated Shapes Complete ")
        root.append(shapes_comment)

        # Add volumes section
        volumes_comment = ET.Comment(" Volumes ")
        root.append(volumes_comment)

        # Write XML file
        try:
            xml_content = self.prettify_xml(root)
            with open(xml_file, 'w', encoding='utf-8') as f:
                f.write(xml_content)
            print(f"‚úì Successfully converted to XML: {xml_file}")
            return True
        except Exception as e:
            print(f"‚ùå Error writing XML file: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(description='Convert YAML configuration to Mitsuba XML scene')
    parser.add_argument('yaml_file', help='Input YAML configuration file')
    parser.add_argument('xml_file', nargs='?', help='Output XML scene file')
    parser.add_argument('--force', '-f', action='store_true', help='Overwrite existing XML file')

    args = parser.parse_args()

    # Generate output filename if not provided
    if not args.xml_file:
        yaml_basename = os.path.splitext(args.yaml_file)[0]
        args.xml_file = f"{yaml_basename}.xml"

    # Check if output file exists
    if os.path.exists(args.xml_file) and not args.force:
        print(f"‚ö†Ô∏è  Output file {args.xml_file} already exists. Use --force to overwrite.")
        return

    # Create converter and perform conversion
    converter = YAMLToXMLConverter()
    success = converter.convert(args.yaml_file, args.xml_file)

    if success:
        print("\nüéâ Conversion completed successfully!")
        print(f"üìÑ Input:  {args.yaml_file}")
        print(f"üìÑ Output: {args.xml_file}")
        print(f"\nüí° You can now use {args.xml_file} with radio_shadowing.py")
    else:
        print("\n‚ùå Conversion failed!")
        sys.exit(1)

if __name__ == '__main__':
    main()